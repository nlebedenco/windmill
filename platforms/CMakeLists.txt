########################################################################################################################
# Definitions
########################################################################################################################
# Directory with our custom CMake modules
cmake_path(SET WINDMILL_MODULES_DIR NORMALIZE "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/modules")

# CMake configurations shared between Desktop, Mobile and Embedded projects
cmake_path(SET WINDMILL_SHARED_CMAKE_FILE NORMALIZE "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/shared.cmake")

########################################################################################################################
# Configuration
########################################################################################################################
include(Windmill/Functions)

# Declare scope variables that are initialized with the value of a cache variable of the same name (if any).
windmill_declare_variables(
        CMAKE_FOLDER
        CMAKE_MODULE_PATH
        CMAKE_PREFIX_PATH
        CMAKE_PROGRAM_PATH
        CMAKE_INCLUDE_PATH
        CMAKE_LIBRARY_PATH
        CMAKE_FIND_ROOT_PATH
)

# Report CMake version used
message(STATUS "CMake version: ${CMAKE_VERSION}")

# Inject the same script we inject after project(Zephyr-Kernel) so we can use the same configuration steps. We could as
# easily call include() after the call to project below but injecting is closer to what we do with embedded might help
# to catch eventual CMake peculiarities that may arise from it.
windmill_declare_variables(CMAKE_PROJECT_WINDMILL_PLATFORMS_INCLUDE)
list(APPEND CMAKE_PROJECT_WINDMILL_PLATFORMS_INCLUDE "${WINDMILL_SHARED_CMAKE_FILE}")

########################################################################################################################
# Project
########################################################################################################################
project(WINDMILL_PLATFORMS LANGUAGES C CXX)

# By default all items named by target_link_libraries() that can be target names are actually names of existing
# targets. In order to link toolchain-provided libraries by name while still enforcing LINK_LIBRARIES_ONLY_TARGETS, use
# an imported Interface Library with the IMPORTED_LIBNAME target property.
# See https://cmake.org/cmake/help/latest/prop_tgt/LINK_LIBRARIES_ONLY_TARGETS.html
option(CMAKE_LINK_LIBRARIES_ONLY_TARGETS "" ON)
mark_as_advanced(CMAKE_LINK_LIBRARIES_ONLY_TARGETS)

# Check multi-config generator build types are all supported.
# CMAKE_CONFIGURATION_TYPES specifies the available build types (configurations) on multi-config generators (e.g. Visual
# Studio, Xcode, or Ninja Multi-Config) as a semicolon-separated list.
# Supported entries are: Debug, Release, RelWithDebInfo and MinSizeRel.
# This variable is initialized by the first project() or enable_language() command called in a project when a new build
# tree is first created. If the CMAKE_CONFIGURATION_TYPES environment variable is set, its value is used. Otherwise, the
# default value is generator-specific. Since this variable could be set by a parent project we cannot enforce it but we
# can check it to make sure it is compatible.
if (DEFINED CMAKE_CONFIGURATION_TYPES)
    set(items ${CMAKE_CONFIGURATION_TYPES})
    list(FILTER items EXCLUDE REGEX "^(Debug|Release|RelWithDebInfo|MinSizeRel)$")
    if (items)
        list(JOIN items "  \n" items)
        message(FATAL_ERROR "Invalid build types:\n" "  ${items}\n")
    endif ()
    unset(items)
endif ()

# Windows DLLs must go into RUNTIME_OUTPUT_DIRECTORY so executables can find their libraries. Set output directories
# here for all targets so we can find dynamic libraries when any of the executables are run.
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/output/$<CONFIG>/bin" CACHE PATH
        "Where to put all the RUNTIME target files when built.")
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/output/$<CONFIG>/lib" CACHE PATH
        "Where to put all the ARCHIVE target files when built.")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/output/$<CONFIG>/lib" CACHE PATH
        "Where to put all the LIBRARY target files when built.")
set(CMAKE_PDB_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/output/$<CONFIG>/lib" CACHE PATH
        "Where to put all the MS PDB files generated by the linker for executable and shared library targets.")

# Set installation prefix to a safe location if one is not explicitly specified
if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
    set(CMAKE_INSTALL_PREFIX "${CMAKE_BINARY_DIR}/install" CACHE PATH "Default install path" FORCE)
endif ()

# Use GNU standard installation directories, which are also defined, to some degree, by autotools, and at least some
# of which are general UN*X conventions. This include must happen AFTER any changes to CMAKE_INSTALL_PREFIX and at least
# one language is enabled.
include(GNUInstallDirs)

message(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")

########################################################################################################################
# Sources
########################################################################################################################
if ("${CMAKE_SYSTEM_NAME}" MATCHES "^(Windows|Linux|Darwin)$")
    add_subdirectory(desktop)
elseif ("${CMAKE_SYSTEM_NAME}" MATCHES "^(Android|iOS|tvOS|watchOS|visionOS)$")
    add_subdirectory(mobile)
else ()
    message(FATAL_ERROR "Invalid target system: ${CMAKE_SYSTEM_NAME}")
endif ()
